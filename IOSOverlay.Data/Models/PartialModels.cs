// PartialModels is a grouping of all partial classes extending the Models and ModelCollections generated by the Models t4 template.
#define DISABLE_CASING
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;
using SharedData.Sync;
using SharedData.Input;
using System.ComponentModel;
using Simulation;
using System.Collections.ObjectModel;
using System.Runtime.CompilerServices;
using System.Diagnostics;

namespace IOSOverlay.Data.Models {
	[KnownType(typeof(UserTypes))]
	[KnownType(typeof(UserPermissionFlags))]
	public partial class UserModel {
		/// <summary>
		/// Gets or sets the user type flag.
		/// <para>Linked to UserType</para>
		/// </summary>
		/// <value>
		/// The user type flag.
		/// </value>
		[IgnoreDataMember, ChangedNotificationLink("UserType")]
		public UserTypes UserTypeFlag {
			get {
				return (UserTypes)this.UserType;
			}
			set {
				if(EditMode) {
					if(this.UserType != (int)value) {
						this.UserType = (int)value;
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		/// <summary>
		/// Gets or sets the user permissions.
		/// <para>Linked to Permissions</para>
		/// </summary>
		/// <value>
		/// The user permissions.
		/// </value>
		[IgnoreDataMember, ChangedNotificationLink("Permissions")]
		public UserPermissionFlags UserPermissions {
			get {
				return (UserPermissionFlags)this.Permissions;
			}
			set {
				if(EditMode) {
					if(this.Permissions != (int)value) {
						this.Permissions = (int)value;
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		/// <summary>
		/// Gets the Users formatted full name.
		/// <para>Name format is: LastName, FirstName MiddleName SirName</para>
		/// </summary>
		/// <value>
		/// The full name.
		/// </value>
		[IgnoreDataMember, ChangedNotificationLink("FirstName"), ChangedNotificationLink("MiddleName"), ChangedNotificationLink("LastName"), ChangedNotificationLink("SirName")]
		public string FullName {
			get {
				var fn = "";
				// Creating these variables so the "has x" operations only have to be performed once, and it improves readability.
				var hasFrst = !string.IsNullOrWhiteSpace(this.FirstName);
				var hasMidd = !string.IsNullOrWhiteSpace(this.MiddleName);
				var hasLast = !string.IsNullOrWhiteSpace(this.LastName);
				var hasSir = !string.IsNullOrWhiteSpace(this.SirName);

#if DISABLE_CASING
				// Add name fragments to full name string in order, capitalizing and inserting commas where appropriate.
				if(hasLast) fn += (this.LastName[0]) + (this.LastName.Length < 2 ? "" : this.LastName.Substring(1)) + (hasFrst || hasMidd || hasSir ? ", " : "");
				if(hasFrst) fn += (this.FirstName[0]) + (this.FirstName.Length < 2 ? "" : this.FirstName.Substring(1)) + (!hasMidd && hasSir ? ", " : " ");
				if(hasMidd) fn += (this.MiddleName[0]) + (this.MiddleName.Length < 2 ? "" : this.MiddleName.Substring(1)) + (hasSir ? ", " : "");
				if(hasSir) fn += (this.SirName[0]) + (this.SirName.Length < 2 ? "" : this.SirName.Substring(1));
#else
				// Add name fragments to full name string in order, capitalizing and inserting commas where appropriate.
				if(hasLast) fn += char.ToUpper(this.LastName[0]) + (this.LastName.Length < 2 ? "" : this.LastName.ToLower().Substring(1)) + (hasFrst || hasMidd || hasSir ? ", " : "");
				if(hasFrst) fn += char.ToUpper(this.FirstName[0]) + (this.FirstName.Length < 2 ? "" : this.FirstName.ToLower().Substring(1)) + (!hasMidd && hasSir ? ", " : " ");
				if(hasMidd) fn += char.ToUpper(this.MiddleName[0]) + (this.MiddleName.Length < 2 ? "" : this.MiddleName.ToLower().Substring(1)) + (hasSir ? ", " : "");
				if(hasSir) fn += char.ToUpper(this.SirName[0]) + (this.SirName.Length < 2 ? "" : this.SirName.ToLower().Substring(1));
#endif

				return fn;
			}
		}
		[IgnoreDataMember]
		public UserModel Creator {
			get {
				// null check not necessary as ModelCollections return null by default.
				return ModelManager.UserCollection[CreatorUID];
			}
		}

		/// <summary>
		/// When overrode in a derived class, called when a new Model is created.
		/// </summary>
		protected internal override void OnCreate() {
			DateCreated = DateTime.Now;
			base.OnCreate();
			ValidateModel();
		}
		/// <summary>
		/// Ends the edit session and overrides the <see cref="Master" /> with the <see cref="_View" />, recording all changes.
		/// </summary>
		public override void EndEdit() {
			if(IsChanged) {
				LastModified = DateTime.Now;
			}
			base.EndEdit();
		}

		public void SetLastActive(DateTime active) {
			using(this.EditToken) {
				this.LastActive = active;
				this.IsChanged = false;
			}
		}
		public void SetArchived(bool archive = true) {
			using(this.EditToken) this.Archived = archive;
		}

		protected override List<string> ValidateProperty(string propertyName) {
			var errors = new List<string>();
			switch(propertyName) {
				case nameof(Password):
					if(string.IsNullOrEmpty(this.Password)) {
						errors.Add("Valid password required.");
					} else if(this.Password.Length < 4) {
						errors.Add("Password must be at least 4 digits.");
					}
					break;
				case nameof(FirstName):
					if(string.IsNullOrEmpty(this.FirstName)) {
						errors.Add("First Name required.");
					}
					break;
				case nameof(LastName):
					if(string.IsNullOrEmpty(this.LastName)) {
						errors.Add("Last Name required.");
					}
					break;
			}
			return errors;
		}

		public void UpdateIOSEditSettings(object settings) {
			using(this.EditToken) this.IOSSettings_Edit = settings;

		}
		public void UpdateIOSRunSettings(object settings) {
			using(this.EditToken) this.IOSSettings_Run = settings;
		}
	}

	[KnownType(typeof(OperatorViewPointPositions))]
	[KnownType(typeof(ControlInputMethodTypes))]
	[KnownType(typeof(UnderhungLiftingDevices))]
	[KnownType(typeof(OperatorAidsModel))]
	//[KnownType(typeof(OperatorAids))]
	public partial class CraneConfigModel:ICommonInformation {
		private bool _IgnoreChanges = false;
		/// <summary>
		/// Gets or sets the view point position.
		/// <para>Linked to ViewPoint.</para>
		/// </summary>
		/// <value>
		/// The view point position.
		/// </value>
		[IgnoreDataMember]
		public OperatorViewPointPositions ViewPointPosition {
			get {
				return (Simulation.OperatorViewPointPositions)this.ViewPoint;
			}
			//set {
			//	if(EditMode) {
			//		if(this.ViewPoint != (int)value) {
			//			this.ViewPoint = (int)value;
			//			this.IsChanged = true;
			//			RaisePropertyChanged();
			//		}
			//	}
			//}
		}
		/// <summary>
		/// Gets or sets the type of the input method.
		/// <para>Linked to InputMethod</para>
		/// </summary>
		/// <value>
		/// The type of the input method.
		/// </value>
		[IgnoreDataMember]
		public ControlInputMethodTypes InputMethodType {
			get {
				return (Simulation.ControlInputMethodTypes)this.InputMethod;
			}
			//set {
			//	if(EditMode) {
			//		if(this.InputMethod != (int)value) {
			//			this.InputMethod = (int)value;
			//			this.IsChanged = true;
			//			RaisePropertyChanged();
			//		}
			//	}
			//}
		}
		/// <summary>
		/// Gets or sets the selected uld.
		/// </summary>
		/// <value>
		/// The selected uld.
		/// </value>
		[IgnoreDataMember]
		public UnderhungLiftingDevices SelectedULD {
			get {
				return (UnderhungLiftingDevices)this.ULDSelection;
			}
			//set {
			//	if(EditMode) {
			//		if(this.ULDSelection != (int)value) {
			//			this.ULDSelection = (int)value;
			//			this.IsChanged = true;
			//			RaisePropertyChanged();
			//		}
			//	}
			//}
		}
		/// <summary>
		/// Gets or sets the operator assistance.
		/// <para>Linked to OperatorAid</para>
		/// </summary>
		/// <value>
		/// The operator assistance.
		/// </value>
		[IgnoreDataMember, ChangedNotificationLink("OperatorAid")]
		public OperatorAidsModel OperatorAssistance {
			get {
				Debug.Assert(this.OperatorAid != null);
				return (this.OperatorAid ?? (this.OperatorAid = new OperatorAidsModel() { IsSubModel = true, State = ModelStates.New })) as OperatorAidsModel;
			}
			set {
				if(EditMode) {
					if(this.OperatorAid != (object)value) {
						this.OperatorAid = value;
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		[IgnoreDataMember]
		public UserModel Creator {
			get {
				return ModelManager.UserCollection[CreatorUID];
			}
		}
		[IgnoreDataMember]
		public override ModelGroupingOptions Grouping {
			get {
				return (this.IsDefault || this.IsBuiltIn) ? ModelGroupingOptions.BuiltIn : base.Grouping;
			}
		}
		[IgnoreDataMember]
		public ModelGroupingOptions BuiltInGrouping {
			get {
				if(this.IsDefault) return ModelGroupingOptions.BuiltIn;
				else return ModelGroupingOptions.Other;
			}
		}

		/// <summary>
		/// When overrode in a derived class, called when a new Model is created.
		/// </summary>
		protected internal override void OnCreate() {
			if(string.IsNullOrWhiteSpace(Name)) {
#pragma warning disable CS0618 // Type or member is obsolete
				Name = "New Configuration " + ID;
#pragma warning restore CS0618 // Type or member is obsolete
			} else {
				Name += " (Copy)";
			}
			if(string.IsNullOrWhiteSpace(Description)) {
				Description = string.Empty;
			}
			DateCreated = DateTime.Now;
			IsDefault = false;
			base.OnCreate();
		}
		internal override object OnCloning<MType>(MType source, MType clone) {
			(clone as CraneConfigModel).OperatorAid = new OperatorAidsModel() { IsSubModel = true, State = ModelStates.New, Master = (source as CraneConfigModel).OperatorAssistance.Master };
			return clone;
		}
		/// <summary>
		/// Ends the edit session and overrides <see cref="_View" /> with the <see cref="Master" />, canceling out all changes.
		/// <para>Cancels the edit session in child <see cref="OperatorAssistance"/></para>
		/// </summary>
		public override void CancelEdit() {
			OperatorAssistance.CancelEdit();
			base.CancelEdit();
		}
		/// <summary>
		/// Ends the edit session and overrides the <see cref="Master" /> with the <see cref="_View" />, recording all changes.
		/// <para>Ends the edit session in child <see cref="OperatorAssistance"/></para>
		/// </summary>
		public override void EndEdit() {
			if(!_IgnoreChanges) {
				LastModified = DateTime.Now;
			}
			OperatorAssistance.EndEdit();
			base.EndEdit();
		}
		/// <summary>
		/// Enter an edit session, overrides the <see cref="_View" /> with the <see cref="Master" /> to ensure the view is up
		/// to date.
		/// <para>Starts an edit session in child <see cref="OperatorAssistance"/></para>
		/// </summary>
		public override void BeginEdit() {
			OperatorAssistance.BeginEdit();
			base.BeginEdit();
		}
		/// <summary>
		/// Generates an instance of <see cref="SharedData.Sync.CraneConfigurationData"/> using this Model.
		/// </summary>
		/// <returns>
		/// A new instance of <see cref="SharedData.Sync.CraneConfigurationData"/> based on this Model.
		/// </returns>
		public CraneConfigurationData ToCraneConfigData() {
			return new CraneConfigurationData(
				this.MaxSwingAngle,
				this.SwingCoefficient,
				this.HoistMaxSpeed,
				this.BringeMaxSpeed,
				this.BridgeDecelerationRate,
				this.TrolleyMaxSpeed,
				this.TrolleyDecelerationRate,
				this.EnableAuxHoist,
				this.EnableAuxTrolley,
				this.SelectedULD,
				this.InputMethodType,
				this.ViewPointPosition
				);
		}
		public void SetLastUsed(DateTime used) {
			using(this.EditToken) this.LastUsed = used;
		}
		public void SetArchived(bool archive = true) {
			using(this.EditToken) this.Archived = archive;
		}
		protected override void RaisePropertyChanged([CallerMemberName] string propertyName = "") {
			base.RaisePropertyChanged(propertyName);
			if(EditMode && IsChanged && propertyName == nameof(InputMethod)) {
				// Set the viewpoint to whatever the default is for this control type so we don't end up with
				// a conflict or incompatable types
				this.ViewPoint = (int)DefaultViewpointAttribute.GetDefaultViewpoint(this.InputMethodType);
				if(this.InputMethodType == ControlInputMethodTypes.Pendent) {
					// Disable the aux trolley/hoist since pendant doesn't support it.
					this.EnableAuxTrolley = false;
					this.EnableAuxHoist = false;
				}
				if(this.InputMethodType != ControlInputMethodTypes.CAB) {
					// Changing the selected ULD to "None" in any situation where the input method is changed.
					this.ULDSelection = 0;
				}

			}
			if(EditMode && IsChanged && propertyName == nameof(EnableAuxHoist)) {
				if(!this.EnableAuxHoist) {
					this.EnableAuxTrolley = false;
				}
			}
		}
		public override void Generalize() {
			_IgnoreChanges = true;
			base.Generalize();
			using(EditToken) {
				DateCreated = new DateTime();
				LastModified = new DateTime();
				LastUsed = new DateTime();
				IsDefault = true;
			}
			_IgnoreChanges = false;
		}

		internal void ProcessOnLoad() {
			if(string.IsNullOrWhiteSpace(Category)) {
				if(!string.IsNullOrWhiteSpace(this.Name)) {
					using(this.EditToken) {
						Category = this.Name.Split(' ').FirstOrDefault();
					}
				}
			}
		}
	}

	public partial class CraneConfigModelCollection {
		/// <summary>
		/// Adds a new <typeparamref name="TModel" /> to this collection, sets it as the <see cref="ActiveSelection" />,
		/// and puts it in edit mode.
		/// <para>Sets the view in new members as a copy of the default view (if exists).</para>
		/// </summary>
		public override void AddNew() {
			if(!ActiveSelectionLocked) {
				if(First != null && First.IsDefault) {
					// All new members are made as a copy of the default.
					var m = ((CraneConfigModel)First.Clone());
					// We're doing the AddNew first, so that the ID of m get's set by this collection.
					AddNew(m);
#pragma warning disable CS0618 // Type or member is obsolete
					// Change the name of the new member, since OnCreate ran during cloning, causing the name to be based on the clone convention.
					m.Name = "New Configuration " + m.ID;
#pragma warning restore CS0618 // Type or member is obsolete
					// clearing the description since it's a clone of the base, but being presented as a new model
					m.Description = string.Empty;
				} else {
					base.AddNew();
				}
			}
		}
		protected internal override void ProcessOnLoadCollection() {
			foreach(var model in this.Models) {
				model.ProcessOnLoad();
			}
		}
	}

	[KnownType(typeof(EnvironmentSettingsModel))]
	[KnownType(typeof(EnvironmentFeatures))]
	public partial class EnvironmentModel:ICommonInformation {
		private const string _BitmapData = "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";

		[IgnoreDataMember]
		private bool _SignificantChange = false;

		/// <summary>
		/// Gets the base environment.
		/// </summary>
		/// <value>
		/// The base environment.
		/// </value>
		/// <remarks>
		/// All environments must be based on a built in scene, custom environments can then
		/// add objects to that scene.
		/// </remarks>
		[IgnoreDataMember, ChangedNotificationLink("BaseEnvironmentID"), ChangedNotificationLink("BaseEnvironmentUID")]
		public EnvironmentModel BaseEnvironment {
			get {
				if(ModelManager.EnvironmentCollection.ContainsUID(this.BaseEnvironmentUID)) {
					return ModelManager.EnvironmentCollection[this.BaseEnvironmentUID];
				} else {
					return this;
				}
			}
			set {
				if(EditMode) {
					if(value != null && this.BaseEnvironmentUID != value.UID && !this.IsBuiltIn) {
						this.BaseEnvironmentUID = value.UID;
#pragma warning disable CS0618 // Type or member is obsolete
						this.BaseEnvironmentID = value.ID;
#pragma warning restore CS0618 // Type or member is obsolete
						this.IsChanged = true;
						Settings.SelectedFeatures = 0;
						RaisePropertyChanged();
					}
				}
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("EnvSettings")]
		public EnvironmentSettingsModel Settings {
			get {
				return (this.EnvSettings ?? (this.EnvSettings = new EnvironmentSettingsModel() { IsSubModel = true, State = ModelStates.New })) as EnvironmentSettingsModel;
			}
			set {
				if(EditMode) {
					if(this.EnvSettings != (object)value) {
						this.EnvSettings = value;
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("EnvSupportedFeatures"), ChangedNotificationLink("BaseEnvironment"), ChangedNotificationLink(nameof(BaseEnvironmentID)), ChangedNotificationLink(nameof(BaseEnvironmentUID))]
		public EnvironmentFeatures SupportedFeatures {
			get {
				if(this.IsBuiltIn) {
					return (EnvironmentFeatures)(this.EnvSupportedFeatures ?? 0);
				} else {
					return (EnvironmentFeatures)(BaseEnvironment?.EnvSupportedFeatures ?? 0);
				}
			}
			set {
				if(EditMode && IsBuiltIn) {
					if(this.EnvSupportedFeatures != (object)value) {
						this.EnvSupportedFeatures = value;
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		[IgnoreDataMember]
		public override ModelGroupingOptions Grouping {
			get {
				return this.IsBuiltIn ? ModelGroupingOptions.BuiltIn : base.Grouping;
			}
		}
		[IgnoreDataMember]
		public ModelGroupingOptions BuiltInGrouping {
			get {
				if(this.IsBuiltIn) return ModelGroupingOptions.BuiltIn;
				else return ModelGroupingOptions.Other;
			}
		}
		[IgnoreDataMember]
		public UserModel Creator {
			get {
				return ModelManager.UserCollection[CreatorUID];
			}
		}
		/// <summary>
		/// Gets the exercise reference count.
		/// </summary>
		/// <value>
		/// The exercise reference count.
		/// </value>
		[IgnoreDataMember]
		public int ExerciseReferenceCount {
			get {
				return ModelManager.ExerciseCollection.Models.Count((a) => a.EnvironmentUID == this.UID && !string.IsNullOrWhiteSpace(a.JSONData) && !a.Archived);
			}
		}

		/// <summary>
		/// When overrode in a derived class, called when a new Model is created.
		/// </summary>
		protected internal override void OnCreate() {
			PreviewImage = "";// _BitmapData;
			if(string.IsNullOrWhiteSpace(Name)) {
#pragma warning disable CS0618 // Type or member is obsolete
				Name = "New Environment " + ID;
#pragma warning restore CS0618 // Type or member is obsolete
			} else {
				Name += " (Copy)";
			}
			if(string.IsNullOrWhiteSpace(Description)) {
				Description = string.Empty;
			}
			DateCreated = DateTime.Now;
			IsBuiltIn = false;
			base.OnCreate();
		}
		protected internal override void OnDelete() {
			LockReferencingExercises();
			base.OnDelete();
		}
		protected override void RaisePropertyChanged([CallerMemberName] string propertyName = "") {
			switch(propertyName) {
				case nameof(Settings):
				case nameof(EnvSettings):
				case nameof(BaseEnvironment):
				case nameof(BaseEnvironmentID):
				case nameof(JSONData):
					_SignificantChange = true;
					break;
				case nameof(BaseEnvironmentUID):
					// don't set _SignificantChange if BaseEnvironmentUID was previously null/empty and model manager is doing first pass UID setup
					if(Master.BaseEnvironmentUID == Guid.Empty && ModelManager.SettingInitialUIDs) break;
					_SignificantChange = true;
					break;
			}
			base.RaisePropertyChanged(propertyName);
		}
		public override void BeginEdit() {
			_SignificantChange = false;
			Settings.BeginEdit();
			base.BeginEdit();
		}
		public override void CancelEdit() {
			_SignificantChange = false;
			base.CancelEdit();
			Settings.CancelEdit();
		}
		public override void EndEdit() {
			if(_SignificantChange) {
				LockReferencingExercises();
				_SignificantChange = false;
				LastModified = DateTime.Now;
			}
			Settings.EndEdit();
			base.EndEdit();
		}
		public override void Generalize() {
			base.Generalize();
			using(EditToken) {
				DateCreated = new DateTime();
				LastModified = new DateTime();
				LastUsed = new DateTime();
				IsBuiltIn = true;
			}
		}
		public void LockReferencingExercises() {
			foreach(var exercise in (from a in ModelManager.ExerciseCollection.Models where a.EnvironmentUID == this.UID select a)) {
				using(exercise.EditToken) exercise.LockedForUpdate = true;
			}
		}
		public void SetLastUsed(DateTime used) {
			using(this.EditToken) {
				_SignificantChange = false;
				this.LastUsed = used;
			}
			if(!IsBuiltIn && BaseEnvironment != null) BaseEnvironment.SetLastUsed(used);
		}
		public void SetArchived(bool archive = true) {
			using(this.EditToken) this.Archived = archive;
		}

		internal void ProcessOnLoad() {
			if(string.IsNullOrWhiteSpace(Category)) {
				if(!string.IsNullOrWhiteSpace(this.Name)) {
					using(this.EditToken) {
						Category = this.Name.Split(' ').FirstOrDefault();
					}
				}
			}
		}
	}

	public partial class EnvironmentModelCollection {
		public override void DuplicateCurrent() {
			if(!ActiveSelectionLocked && !ActiveSelectionNull) {
				var mb = ((EnvironmentModel)ActiveSelection.Clone());
				var m = mb.Master;
				m.IsBuiltIn = false;
				m.EnvSettings = null;// ((EnvironmentSettingsModel)mb.Settings.Clone());
				AddNew(m);
			}
			//base.DuplicateCurrent();
		}

		/// <summary>
		/// Synchronizes the environments with simulation.
		/// </summary>
		/// <remarks>
		/// Experimental Feature. Not for Production.
		/// </remarks>
		[Obsolete]
		public async void SyncEnvironmentsWithSimulation() {
			await Task.Run(() => {
				while(!SyncIOS.Instance.SimulationEnvironmentsListLoaded) {
					System.Threading.Thread.Sleep(100);
				}
				var builtIn = this.Models.Where((a) => a.IsBuiltIn);
				if(builtIn.Count() != SyncIOS.Instance.SimulationEnvironments.Count) {
					BeginInit();
					int index = builtIn.Count();
					foreach(var env in SyncIOS.Instance.SimulationEnvironments) {
						var envUpdateData = new EnvironmentModel();
						envUpdateData.IsBuiltIn = true;
						envUpdateData.InternalName = env.LevelName;
						envUpdateData.SupportedFeatures = env.SupportedFeatures;
						envUpdateData.Name = env.EnvironmentName;
						envUpdateData.Description = env.Description;

						if(builtIn.Any((a) => a.InternalName.Equals(env.LevelName))) {
							envUpdateData.ID = builtIn.First((a) => a.InternalName.Equals(env.LevelName)).ID;
						} else {
							envUpdateData.ID = index++;
						}
						UpdateAddModel(envUpdateData);
					}
					EndInit();
				}
			});
		}

		protected internal override void UpdateUniqueReferencing() {
			base.UpdateUniqueReferencing();
			foreach(var m in Models) {
				if(m.BaseEnvironmentUID == Guid.Empty) {
					if(m.BaseEnvironmentID != -1) {
						using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
							m.BaseEnvironmentUID = this[m.BaseEnvironmentID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
						}
					}
				}
			}
		}

		protected internal override void ProcessOnLoadCollection() {
			foreach(var model in this.Models) {
				model.ProcessOnLoad();
			}
		}
	}

	public partial class EnvironmentSettingsModel {
		protected override List<string> ValidateProperty(string propertyName) {
			var errors = new List<string>();
			switch(propertyName) {
				case nameof(this.SelectedFeatures):
					if(SelectedFeatures.HasFlag(EnvironmentFeatures.Train) && SelectedFeatures.HasFlag(EnvironmentFeatures.Truck)) {
						errors.Add("Train and Truck Cannot both be enabled at the same time.");
					}
					break;
			}
			return errors;
		}
	}

	[KnownType(typeof(ScoringDeductionsModel))]
	[KnownType(typeof(OperatorAidsModel))]
	[KnownType(typeof(StartConditions))]
	[KnownType(typeof(EndConditions))]
	public partial class ExerciseModel:ICommonInformation {
		private bool _IgnoreChanges = false;
		/// <summary>
		/// Gets or sets the environment.
		/// <para>Linked to EnvironmentID</para>
		/// </summary>
		/// <value>
		/// The environment.
		/// </value>
		[IgnoreDataMember, ChangedNotificationLink("EnvironmentID"), ChangedNotificationLink("EnvironmentUID")]
		public EnvironmentModel Environment {
			get {
				// Environment delete/removal protection
				if(!ModelManager.EnvironmentCollection.ContainsUID(this.EnvironmentUID)) {
					ResetEnvironment();
				}
				return ModelManager.EnvironmentCollection[this.EnvironmentUID];
			}
			set {
				if(EditMode) {
					if(value != null && this.EnvironmentUID != value.UID) {
						this.EnvironmentUID = value.UID;
#pragma warning disable CS0618 // Type or member is obsolete
						this.EnvironmentID = value.ID;
#pragma warning restore CS0618 // Type or member is obsolete
						this.IsChanged = true;
						if(string.IsNullOrWhiteSpace(this.JSONData)) {
							this.LockedForUpdate = false;
						}
						RaisePropertyChanged();
					}
				}
			}
		}
		/// <summary>
		/// Gets or sets the crane configuration.
		/// </summary>
		/// <value>
		/// The crane configuration.
		/// </value>
		[IgnoreDataMember, ChangedNotificationLink("CraneConfigID"), ChangedNotificationLink("CraneConfigUID")]
		public CraneConfigModel CraneConfiguration {
			get {
				// Crane config delete/removal protection
				if(!ModelManager.CraneConfigCollection.ContainsUID(this.CraneConfigUID)) {
					ResetCraneConfiguration();
				}
				return ModelManager.CraneConfigCollection[this.CraneConfigUID];
			}
			set {
				if(EditMode) {
					if(value != null && this.CraneConfigUID != value.UID) {
						this.CraneConfigUID = value.UID;
#pragma warning disable CS0618 // Type or member is obsolete
						this.CraneConfigID = value.ID;
#pragma warning restore CS0618 // Type or member is obsolete
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		/// <summary>
		/// Gets or sets the score settings.
		/// <para>Linked to ScoringSettings</para>
		/// </summary>
		/// <value>
		/// The score settings.
		/// </value>
		//[IgnoreDataMember, ChangedNotificationLink("ScoringSettings")]
		//public ScoringDeductionsModel OldScoreSettings {
		//	get {
		//		return (this.ScoringSettings ?? (this.ScoringSettings = new ScoringDeductionsModel() { IsSubModel = true, State = ModelStates.New, Master = ScoringDeductions.Default })) as ScoringDeductionsModel;
		//	}
		//	set {
		//		if(EditMode) {
		//			if(this.EnvSettings != (object)value) {
		//				this.EnvSettings = value;
		//				this.IsChanged = true;
		//				RaisePropertyChanged();
		//				RaisePropertyChanged("ScoringSettings");
		//			}
		//		}
		//	}
		//}
		[IgnoreDataMember, ChangedNotificationLink("ScoringSetID"), ChangedNotificationLink("ScoringSetUID")]
		public ScoringDeductionsModel ScoreSettings {
			get {
				if(!ModelManager.ScoringSetsCollection.ContainsUID(this.ScoringSetUID)) {
					ResetScoringSet();
				}
				return ModelManager.ScoringSetsCollection[this.ScoringSetUID];
			}
			set {
				if(EditMode) {
					if(value != null && this.ScoringSetUID != value.UID) {
						this.ScoringSetUID = value.UID;
#pragma warning disable CS0618 // Type or member is obsolete
						this.ScoringSetID = value.ID;
#pragma warning restore CS0618 // Type or member is obsolete
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		/// <summary>
		/// Gets or sets the operator assistance.
		/// <para>Linked to OperatorAid</para>
		/// </summary>
		/// <value>
		/// The operator assistance.
		/// </value>
		[IgnoreDataMember, ChangedNotificationLink("OperatorAids")]
		public OperatorAidsModel OperatorAssistance {
			get {
				//Debug.Assert(this.OperatorAids != null);
				return (this.OperatorAids/* ?? (this.OperatorAids = new OperatorAidsModel() { IsSubModel = true, State = ModelStates.New })*/) as OperatorAidsModel;
			}
			set {
				if(EditMode) {
					if(this.OperatorAids != (object)value) {
						this.OperatorAids = value;
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("StartFlags")]
		public StartConditions StartConditionFlags {
			get {
				return (StartConditions)this.StartFlags;
			}
			set {
				if(EditMode) {
					if(this.StartFlags != (int)value) {
						this.StartFlags = (int)value;
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("EndFlags")]
		public EndConditions EndConditionFlags {
			get {
				return (EndConditions)this.EndFlags;
			}
			set {
				if(EditMode) {
					if(this.EndFlags != (int)value) {
						this.EndFlags = (int)value;
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		/// <summary>
		/// Gets or sets the type of the input method.
		/// <para>Linked to InputMethod</para>
		/// </summary>
		/// <value>
		/// The type of the input method.
		/// </value>
		[IgnoreDataMember]
		public ControlInputMethodTypes InputMethodType {
			get {
				return (Simulation.ControlInputMethodTypes)this.InputMethod;
			}
		}
		[IgnoreDataMember]
		public UserModel Creator {
			get {
				return ModelManager.UserCollection[CreatorUID];
			}
		}
		[IgnoreDataMember]
		public override ModelGroupingOptions Grouping {
			get {
				return (this.CreatorUID == Guid.Empty || this.IsBuiltIn || this.PackageReference.IsValid) ? ModelGroupingOptions.BuiltIn : base.Grouping;
			}
		}

		/// <summary>
		/// Resets the environment.
		/// </summary>
		private void ResetEnvironment() {
			using(EditToken) {
				this.EnvironmentUID = ModelManager.EnvironmentCollection.FirstUID;
				this.EnvironmentID = ModelManager.EnvironmentCollection.FirstID;
			}
		}
		/// <summary>
		/// Resets the scoring set.
		/// </summary>
		private void ResetScoringSet(bool custom = false) {
			using(EditToken) {
				if(custom) {
					ModelManager.ScoringSetsCollection.AddNew();
					ModelManager.ScoringSetsCollection.EndEditActiveSelection();
					this.ScoringSetUID = ModelManager.ScoringSetsCollection.ActiveUID;
#pragma warning disable CS0618 // Type or member is obsolete
					this.ScoringSetID = ModelManager.ScoringSetsCollection.ActiveSelection.ID;
#pragma warning restore CS0618 // Type or member is obsolete
				} else {
					this.ScoringSetUID = ModelManager.ScoringSetsCollection.FirstUID;
					this.ScoringSetID = ModelManager.ScoringSetsCollection.FirstID;
				}
			}
		}
		/// <summary>
		/// Resets the crane configuration.
		/// </summary>
		private void ResetCraneConfiguration() {
			using(EditToken) {
				this.CraneConfigUID = ModelManager.CraneConfigCollection.FirstUID;
				this.CraneConfigID = ModelManager.CraneConfigCollection.FirstID;
			}
		}
		/// <summary>
		/// When overrode in a derived class, called when a new Model is created.
		/// </summary>
		protected internal override void OnCreate() {
			if(string.IsNullOrWhiteSpace(Name)) {
#pragma warning disable CS0618 // Type or member is obsolete
				Name = "New Exercise " + ID;
#pragma warning restore CS0618 // Type or member is obsolete
			} else {
				Name += " (Copy)";
			}
			if(string.IsNullOrWhiteSpace(Description)) {
				Description = string.Empty;
			}
			DateCreated = DateTime.Now;
			StartConditionFlags = StartConditions.Default;
			EndConditionFlags = EndConditions.Default;
			if(OperatorAids == null) {
				OperatorAids = new OperatorAidsModel() { IsSubModel = true, State = ModelStates.New };
			}
			EnvironmentUID = ModelManager.EnvironmentCollection.FirstUID;
			CraneConfigUID = ModelManager.CraneConfigCollection.FirstUID;
			//ResetScoringSet(true);
			base.OnCreate();
		}
		/// <summary>
		/// Generates a new instance of <see cref="SharedData.Sync.ExerciseConfigurationData"/> based on this Model.
		/// </summary>
		/// <returns>
		/// An instance of <see cref="SharedData.Sync.ExerciseConfigurationData"/> based on this Model.
		/// </returns>
		public ExerciseConfigurationData ToExConfiguration() {
			return new ExerciseConfigurationData(
				this.Environment.BaseEnvironment.InternalName,
				this.Name,
				this.CraneConfiguration.ToCraneConfigData(),
				this.JSONData ?? "",
				this.Environment.JSONData ?? "",
				this.Environment.Settings,
				this.ScoreSettings,
				this.OperatorAssistance,
				StartConditionFlags,
				EndConditionFlags,
				ExerciseTimeLimit,
				InputMethodType
				);
		}
		/// <summary>
		/// Ends the edit session and overrides <see cref="_View" /> with the <see cref="Master" />, canceling out all changes.
		/// </summary>
		public override void CancelEdit() {
			OperatorAssistance?.CancelEdit();
			base.CancelEdit();
			//EnviroSettings.CancelEdit();
			//ScoreSettings.CancelEdit();
			//OperatorAssistance.CancelEdit();
		}
		/// <summary>
		/// Ends the edit session and overrides the <see cref="Master" /> with the <see cref="_View" />, recording all changes.
		/// </summary>
		public override void EndEdit() {
			//EnviroSettings.EndEdit();
			//ScoreSettings.EndEdit();
			//OperatorAssistance.EndEdit();
			OperatorAssistance?.EndEdit();
			if(!_IgnoreChanges) {
				LastModified = DateTime.Now;
			}
			base.EndEdit();
		}
		/// <summary>
		/// Enter an edit session, overrides the <see cref="_View" /> with the <see cref="Master" /> to ensure the view is up
		/// to date.
		/// </summary>
		public override void BeginEdit() {
			OperatorAssistance?.BeginEdit();
			base.BeginEdit();
			//EnviroSettings.BeginEdit();
			//ScoreSettings.BeginEdit();
			//OperatorAssistance.BeginEdit();
		}
		public void SetLastUsed(DateTime used) {
			using(this.EditToken) this.LastUsed = DateTime.Now;
			// Disabled as the broadcast of changes caused a full change report which locked exercises
			//if(Environment != null) Environment.SetLastUsed(used);
			if(CraneConfiguration != null) CraneConfiguration.SetLastUsed(used);
		}
		public void SetArchived(bool archive = true) {
			using(this.EditToken) this.Archived = archive;
		}
		public override void Generalize() {
			_IgnoreChanges = true;
			base.Generalize();
			using(EditToken) {
				DateCreated = new DateTime();
				LastUsed = new DateTime();
				LastModified = new DateTime();
			}
			_IgnoreChanges = false;
		}
		internal void ProcessOnLoad() {
			// if the operator aids settings for this exercise don't exist, then they need to be carried over from the associated crane configuration
			if(this.OperatorAids == null) {
				using(this.EditToken) {
					this.OperatorAids = this.CraneConfiguration.OperatorAssistance.Clone();
					this.OperatorAssistance.IsSubModel = true;
				}
			}
			if(string.IsNullOrWhiteSpace(Category)) {
				if(!string.IsNullOrWhiteSpace(this.Name)) {
					using(this.EditToken) {
						Category = this.Name.Split(' ').FirstOrDefault();
					}
				}
			}

		}
		internal override object OnCloning<MType>(MType source, MType clone) {
			(clone as ExerciseModel).OperatorAids = new OperatorAidsModel() { IsSubModel = true, State = ModelStates.New, Master = (source as ExerciseModel).OperatorAssistance.Master };
			(clone as ExerciseModel).CraneConfigUID = (source as ExerciseModel).CraneConfigUID;
			(clone as ExerciseModel).EnvironmentUID = (source as ExerciseModel).EnvironmentUID;
			(clone as ExerciseModel).EndConditionFlags = (source as ExerciseModel).EndConditionFlags;
			return clone;
		}
		protected override void RaisePropertyChanged([CallerMemberName] string propertyName = "") {
			base.RaisePropertyChanged(propertyName);
			if(EditMode && IsChanged && ((propertyName == nameof(CraneConfiguration)) || (propertyName == nameof(CraneConfigUID)))) {
				if(InputMethod != CraneConfiguration.InputMethod) {
					InputMethod = CraneConfiguration.InputMethod;
				}
			}
		}
	}

	public partial class ExerciseModelCollection {
		protected internal override void UpdateUniqueReferencing() {
			base.UpdateUniqueReferencing();
			foreach(var m in Models) {
#pragma warning disable CS0618 // Type or member is obsolete ; warning disabled as this is compatibility code
				if(m.CraneConfigUID == Guid.Empty && ModelManager.CraneConfigCollection.ContainsID(m.CraneConfigID)) {
					using(m.EditToken) {
						m.CraneConfigUID = ModelManager.CraneConfigCollection[m.CraneConfigID].UID;
					}
				}
				if(m.EnvironmentUID == Guid.Empty && ModelManager.EnvironmentCollection.ContainsID(m.EnvironmentID)) {
					using(m.EditToken) {
						m.EnvironmentUID = ModelManager.EnvironmentCollection[m.EnvironmentID].UID;
					}
				}
				if(m.ScoringSetUID == Guid.Empty && ModelManager.ScoringSetsCollection.ContainsID(m.ScoringSetID)) {
					using(m.EditToken) {
						m.ScoringSetUID = ModelManager.ScoringSetsCollection[m.ScoringSetID].UID;
					}
				}
#pragma warning restore CS0618 // Type or member is obsolete
			}
		}
		protected internal override void ProcessOnLoadCollection() {
			foreach(var model in this.Models) {
				// process 
				model.ProcessOnLoad();
			}
		}
	}

	public partial class ReportModelCollection {

		/// <summary>
		/// Generates a new report from a completed session and sets it as the <seealso cref="P:ReportModelCollection.ActiveSelection"/>.
		/// </summary>
		/// <param name="results">The <see cref="SharedData.Sync.ExerciseSessionResults"/> from the session.</param>
		/// <param name="startTime">The start time.</param>
		/// <param name="exercise">The <see cref="ExerciseModel"/> Used in the session.</param>
		/// <param name="user">The <see cref="UserModel"/> that participated in the session.</param>
		public void GenerateReport(ExerciseSessionResults results, DateTime startTime, ExerciseModel exercise, UserModel user) {
			GenerateReport(results, startTime, exercise, user != null ? user.FullName : "NULL", user.ID, user.UID);
		}

		/// <summary>
		/// Generates a new report and sets it as the <seealso cref="P:ReportModelCollection.ActiveSelection"/>.
		/// </summary>
		/// <param name="results">The <see cref="SharedData.Sync.ExerciseSessionResults"/> from the session.</param>
		/// <param name="startTime">The start time.</param>
		/// <param name="exercise">The <see cref="ExerciseModel"/> Used in the session.</param>
		/// <param name="userName">Name of the user that participated in the session.</param>
		/// <param name="userID">The id of the user that participated in the session.</param>
		public void GenerateReport(ExerciseSessionResults results, DateTime startTime, ExerciseModel exercise, string userName, int userID, Guid userUID) {
			System.Diagnostics.Debug.Assert(!this.ActiveSelectionLocked, "ERROR: Cannot Generate Report while the active report is locked.");
			System.Diagnostics.Debug.Assert(results != null, "ERROR: parameter results is null.");
			System.Diagnostics.Debug.Assert(exercise != null, "ERROR: parameter exercise is null.");
			if(!this.ActiveSelectionLocked) {
				var x = new Report() {
					UserID = userID,
					UserUID = userUID,
					UserName = userName,
					GroupName = "---",
					GroupID = -1,
					GroupUID = Guid.Empty,
					GroupAssignmentID = -1,
					GroupAssignmentUID = Guid.Empty,
					AssignedDate = startTime,
					AssignmentName = "---",

					PracticeAllowed = false,
					PracticeUsed = false,

					MaxAttempts = 1,
					AttemptsCount = 1,
					BestAttemptIndex = 0,
					AttemptsData = new AttemptDataModel[1],
					MinPassingScore = exercise.ScoreSettings.MinimumPassingScore,

					ExerciseName = exercise.Name,
					ExerciseCategory = exercise.Category,
					ExerciseID = exercise.ID,
					ExerciseUID = exercise.UID,
					//ExerciseCopy = exercise.Master, // -- To be implemented when testable

					EnvironmentName = exercise.Environment.Name,
					BaseEnvironment = exercise.Environment.BaseEnvironment.Name,

					Configuration = exercise.CraneConfiguration.Name,
					//CraneConfigCopy = exercise.CraneConfiguration.Master, // -- To be implemented when testable

					ScoringSet = exercise.ScoreSettings.Name,
					//ScoringSetCopy = exercise.ScoreSettings.Master, // -- To be implemented when testable

					ViewPoint = exercise.CraneConfiguration.ViewPointPosition.ToString(),
					Controls = exercise.InputMethodType.ToString(),
					CompletionDate = results.CompletionDate,

				};
				x.AttemptsData[x.BestAttemptIndex] = AttemptDataModel.FromExerciseResults(results.Results, exercise, 1);

				this.AddNew(x);
				this.ActiveSelection.EndEdit();
			}
		}

		public Report GenerateReportData(ExerciseSessionResults results, DateTime startTime, ExerciseModel exercise, string userName, int userID, Guid userUID) {
			System.Diagnostics.Debug.Assert(results != null, "ERROR: parameter results is null.");
			System.Diagnostics.Debug.Assert(exercise != null, "ERROR: parameter exercise is null.");

			var x = new Report() {
				UserID = userID,
				UserUID = userUID,
				UserName = userName,
				GroupName = "---",
				GroupID = -1,
				GroupUID = Guid.Empty,
				GroupAssignmentID = -1,
				GroupAssignmentUID = Guid.Empty,
				AssignedDate = startTime,
				AssignmentName = "---",

				PracticeAllowed = false,
				PracticeUsed = false,

				MaxAttempts = 1,
				AttemptsCount = 1,
				BestAttemptIndex = 0,
				AttemptsData = new AttemptDataModel[1],
				MinPassingScore = exercise.ScoreSettings.MinimumPassingScore,
				ExerciseName = exercise.Name,
				EnvironmentName = exercise.Environment.Name,
				BaseEnvironment = exercise.Environment.BaseEnvironment.Name,
				Configuration = exercise.CraneConfiguration.Name,
				ViewPoint = exercise.CraneConfiguration.ViewPointPosition.ToString(),
				Controls = exercise.InputMethodType.ToString(),
				CompletionDate = results.CompletionDate,
				ExerciseCategory = exercise.Category,
				ScoringSet = exercise.ScoreSettings.Name,
				ExerciseID = exercise.ID,
				ExerciseUID = exercise.UID,

			};
			x.AttemptsData[x.BestAttemptIndex] = AttemptDataModel.FromExerciseResults(results.Results, exercise, 1);

			return x;
		}

		[Obsolete]
		public Report GenerateReportData(AssignmentModel assignment, DateTime completionDate) {
			return new Report();
		}
		/// <summary>
		/// Generates the running report2.
		/// </summary>
		/// <param name="assignment">The assignment.</param>
		/// <returns>UID of report</returns>
		public Guid GenerateRunningReport2(AssignmentModel assignment) {
			System.Diagnostics.Debug.Assert(!this.ActiveSelectionLocked, "ERROR: Cannot Generate Report while the active report is locked.");
			System.Diagnostics.Debug.Assert(assignment != null, "ERROR: Parameter assignment is null.");
			if(!this.ActiveSelectionLocked) {
				var x = new Report() {
					UserID = /*assignment.User?.ID ??*/ -1,
					UserUID = assignment.User?.UID ?? Guid.Empty,
					UserName = assignment.User?.FullName ?? "NULL",
					GroupName = assignment.Group?.Name ?? "---",
					GroupID = assignment.GroupID,
					GroupUID = assignment.GroupUID,
					GroupAssignmentID = assignment.GroupAssignmentID,
					GroupAssignmentUID = assignment.GroupAssignmentUID,
					AssignedDate = assignment.CreationDate,
					AssignmentName = assignment.AssignmentName,

					PracticeAllowed = assignment.AllowPractice,
					PracticeUsed = false,

					MaxAttempts = assignment.MaxAttempts,
					AttemptsCount = assignment.AttemptsTaken,
					AttemptsData = new AttemptDataModel[0],
					BestAttemptIndex = -1,
					MinPassingScore = assignment.Exercise.ScoreSettings.MinimumPassingScore,
					ExerciseName = assignment.Exercise?.Name ?? "NULL",
					EnvironmentName = assignment.Exercise?.Environment?.Name ?? "NULL",
					BaseEnvironment = assignment.Exercise?.Environment?.BaseEnvironment?.Name ?? "NULL",
					Configuration = assignment.Exercise?.CraneConfiguration.Name.ToString() ?? "NULL",
					ViewPoint = assignment.Exercise?.CraneConfiguration.ViewPointPosition.ToString() ?? "NULL",
					Controls = assignment.Exercise?.InputMethodType.ToString() ?? "NULL",
					ScoringSet = assignment.Scoring?.Name ?? "NULL",
					ExerciseUID = assignment.ExerciseUID,
					ExerciseCategory = assignment.Exercise?.Category ?? "NULL",

				};

				this.AddNew(x);
				this.EndEditActiveSelection();
				return this.ActiveUID;
			}
			return Guid.Empty;
		}


		public void UpdateRunningReport(AssignmentModel assignment, ExerciseResults results) {
			if(!this.ActiveSelectionLocked) {
				var report = assignment.LinkedReport;
				if(report != null) {
					report.BeginEdit();

					//>>>>>---- Update report with updated assignment data just in case the assignment itself was modified

					report.PracticeAllowed = assignment.AllowPractice;
					report.MaxAttempts = assignment.MaxAttempts;

					//<<<<<----


					var attdatlist = report.Attempts.ToList();
					attdatlist.Add(AttemptDataModel.FromExerciseResults(results, assignment.Exercise, assignment.AttemptsTaken));
					report.AttemptsData = attdatlist.ToArray();

					// find highest score out of all attempts
					var bestScore = attdatlist.Max(m => m.Score);
					// get list of all attempts that have the same top score
					var atmScored = from adm in attdatlist where adm.Score == bestScore orderby adm.RunTime select adm;
					// selected the attempt with the best score and lowest time
					var bestTime = atmScored.Min(m => m.RunTime);
					// get the index of the attempt with the best score and lowest time
					int index = attdatlist.FindIndex(m => m.Score == bestScore && m.RunTime == bestTime);

					report.AttemptsCount = assignment.AttemptsTaken;
					report.BestAttemptIndex = index;// assignment.BestAttempt - 1; //-1 because best attempt is 1 based, while index is 0 based

					if(assignment.Complete) {
						report.CompletionDate = results.CompletionDate;
					}


					report.EndEdit();
				}
			}
		}

		/// <summary>
		/// Calculates the score.
		/// </summary>
		/// <param name="results">The results.</param>
		/// <param name="pointValues">The point values.</param>
		/// <returns></returns>
		internal static int CalculateScore(ExerciseResults results, ScoringDeductions pointValues) {
			var deductions =
				((results.LoadCollisionsCount * pointValues.LoadCollisionDeduction) +
				(results.HookCollisionsCount * pointValues.HookCollisionDeduction) +
				(results.SwingPenaltiesCount * pointValues.ExcessiveSwingDeduction) +
				(results.HeightPenaltiesCount * pointValues.LoadHeightDeduction)) /*+
				(results.PowerlineProximityPenalties * pointValues.PowerlineProximityPenalty) +
				(results.PowerlineContactPenalties * pointValues.PowerlineContactPenalty) +
				(results.WarningAcknowledgmentFailures * pointValues.WarningAcknowledgementFailurePenalty)*/;

			// TODO calculate deductions for enabled penalties

			// calculated score is based on all deductions out of 100, minimum score is 0.
			var score = Math.Max(100 - (int)deductions, 0);

			if(!results.ExerciseCompleted) {
				score = Math.Min(score, pointValues.IncompleteExerciseMaxScore);
			}

			return score;
		}

		protected internal override void UpdateUniqueReferencing() {
			base.UpdateUniqueReferencing();
			foreach(var m in Models) {
				if(m.UserUID == Guid.Empty && ModelManager.UserCollection.ContainsID(m.UserID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.UserUID = ModelManager.UserCollection[m.UserID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
				if(m.GroupUID == Guid.Empty && ModelManager.GroupCollection.ContainsID(m.GroupID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.GroupUID = ModelManager.GroupCollection[m.GroupID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
				if(m.ExerciseUID == Guid.Empty && ModelManager.ExerciseCollection.ContainsID(m.ExerciseID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.ExerciseUID = ModelManager.ExerciseCollection[m.ExerciseID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
				if(m.GroupAssignmentUID == Guid.Empty && ModelManager.GroupAssignmentsCollection.ContainsID(m.GroupAssignmentID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.GroupAssignmentUID = ModelManager.GroupAssignmentsCollection[m.GroupAssignmentID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
			}
		}
	}

	[KnownType(typeof(AttemptDataModel))]
	public partial class ReportModel {
		[IgnoreDataMember]
		public int Score {
			get { return BestAttempt.Score; }
		}
		[IgnoreDataMember]
		public bool Passed {
			get { return BestAttempt.Passed; }
		}
		[IgnoreDataMember]
		public int RunTime {
			get { return BestAttempt.RunTime; }
		}
		[IgnoreDataMember]
		public int HookCollisions {
			get { return BestAttempt.HookCollisions; }
		}
		[IgnoreDataMember]
		public int LoadCollisions {
			get { return BestAttempt.LoadCollisions; }
		}
		[IgnoreDataMember]
		public int ExcessiveSwingingPenalty {
			get { return BestAttempt.ExcessiveSwingingPenalty; }
		}
		[IgnoreDataMember]
		public int LoadHeightPenalty {
			get { return BestAttempt.LoadHeightPenalty; }
		}
		[IgnoreDataMember, ChangedNotificationLink("AttemptsData")]
		public AttemptDataModel[] Attempts {
			get {
				//return (AttemptDataModel[])this.AttemptsData;
				return Array.ConvertAll<object, AttemptDataModel>(this.AttemptsData, new Converter<object, AttemptDataModel>((a) => (AttemptDataModel)a));
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("BestAttemptIndex")]
		public AttemptDataModel BestAttempt {
			get {
				if(this.BestAttemptIndex >= 0 && this.BestAttemptIndex < Attempts.Length) {
					return Attempts[this.BestAttemptIndex];
				} else {
					return Attempts.FirstOrDefault() ?? new AttemptDataModel() { IsSubModel = true, CollectionMember = false, ID = -1 };
				}
			}
		}
		[IgnoreDataMember]
		public ExerciseModel TargetExercise {
			get {
				if(ModelManager.ExerciseCollection.ContainsUID(this.ExerciseUID)) {
					return ModelManager.ExerciseCollection[this.ExerciseUID];
				}
				return null;
			}
		}

		/// <summary>
		/// Generates an immutable 
		/// </summary>
		/// <param name="report">The report.</param>
		/// <returns></returns>
		public static ReportModel ReadOnlyModel(Report report) {
			return new ReportModel() { Master = report, IsSubModel = true, State = ModelStates.ReadOnly };
		}

		public static ReportModel ReadOnlyTempModel(ExerciseResults results, AssignmentModel assignment) {
			var x = new Report() {
				UserID = /*assignment.User?.ID ??*/ -1,
				UserUID = assignment.User?.UID ?? Guid.Empty,
				UserName = assignment.User?.FullName ?? "NULL",

				AssignedDate = assignment.CreationDate,
				AssignmentName = assignment.AssignmentName,

				MaxAttempts = assignment.MaxAttempts,
				AttemptsCount = assignment.AttemptsTaken,
				AttemptsData = new AttemptDataModel[1],
				BestAttemptIndex = 0,

				ExerciseName = assignment.Exercise?.Name ?? "NULL",
				ExerciseCategory = assignment.Exercise?.Category ?? "NULL",
				EnvironmentName = assignment.Exercise?.Environment?.Name ?? "NULL",
				BaseEnvironment = assignment.Exercise?.Environment?.BaseEnvironment?.Name ?? "NULL",
				Configuration = assignment.Exercise?.CraneConfiguration.Name.ToString() ?? "NULL",
				ScoringSet = assignment.Scoring?.Name ?? "NULL",
				ViewPoint = assignment.Exercise?.CraneConfiguration.ViewPointPosition.ToString() ?? "NULL",
				Controls = assignment.Exercise?.InputMethodType.ToString() ?? "NULL",

				CompletionDate = results.CompletionDate,
				GroupName = assignment.Group?.Name ?? "",
				MinPassingScore = assignment.Scoring.MinimumPassingScore,
				PracticeAllowed = assignment.AllowPractice,

			};
			x.AttemptsData[x.BestAttemptIndex] = AttemptDataModel.FromExerciseResults(results, assignment.Exercise, assignment.AttemptsTaken);
			return ReadOnlyModel(x);
		}

		public static ReportModel GenerateFake() {
			Random rand = new Random();
			var mt = rand.Next(3, 16);
			var x = new Report() {
				ExerciseID = -1,
				ExerciseUID = Guid.Empty,
				UserID = -1,
				UserUID = Guid.Empty,
				GroupID = -1,
				GroupUID = Guid.Empty,
				UserName = "Jane, Doe",

				AssignedDate = DateTime.Now,
				AssignmentName = "Test Assignment " + rand.Next(1, 15),
				MaxAttempts = mt,
				AttemptsCount = rand.Next(3, mt),
				BestAttemptIndex = rand.Next(0, 6),
				ExerciseName = "Test Course 1A",
				EnvironmentName = "Test Course",
				BaseEnvironment = "Empty Industrial Lot",
				Configuration = "Default TB-80",
				ScoringSet = "Easy something",
				ViewPoint = "Cab_Bridge_Right_Facing_North",
				Controls = "Joysticks Type A",
				CompletionDate = DateTime.Now,
				GroupName = "Some Group",
				Comments = "This is a test comment",
				MinPassingScore = rand.Next(50, 90),
				ExerciseCategory = "Module " + rand.Next(1, 15) + ":",
				PracticeAllowed = rand.Next(1, 10) % 2 == 1,

			};
			//var adata = new AttemptDataModel[x.AttemptsCount];
			var adata = new List<AttemptDataModel>();
			for(int i = 0; i < x.AttemptsCount; i++) {
				var adm = new AttemptDataModel() { IsSubModel = true };
				((AttemptDataModel)adm).BeginEdit();
				((AttemptDataModel)adm).AttemptNum = 1 + i;
				((AttemptDataModel)adm).HookCollisions = rand.Next(0, 5);
				((AttemptDataModel)adm).LoadCollisions = rand.Next(0, 6);
				((AttemptDataModel)adm).ExcessiveSwingingPenalty = rand.Next(0, 3);
				((AttemptDataModel)adm).LoadHeightPenalty = rand.Next(0, 4);
				((AttemptDataModel)adm).PenaltyFlags = (int)(ExercisePenalties.CraneRanWhileOutOfLevel | ExercisePenalties.TwoBlockedCrane | ExercisePenalties.OverloadedCrane | ExercisePenalties.LMIConfigurationIncorrect | ExercisePenalties.TippedCrane | ExercisePenalties.UsedBrake | ExercisePenalties.UsedThrottle);

				((AttemptDataModel)adm).CatastrophicFailure = (rand.Next(0, 1) == 1 ? true : false);
				((AttemptDataModel)adm).PowerLineContactPenalties = rand.Next(0, 3);
				((AttemptDataModel)adm).PowerLineProximityPenalties = rand.Next(0, 3);
				((AttemptDataModel)adm).ConeCollisions = rand.Next(0, 3);
				((AttemptDataModel)adm).WarningAcknowledgementFailures = rand.Next(0, 3);
				((AttemptDataModel)adm).UnableToContinue = (rand.Next(0, 1) == 1 ? true : false);
				((AttemptDataModel)adm).TimeLimitReached = (rand.Next(0, 1) == 1 ? true : false);
				((AttemptDataModel)adm).RunTime = rand.Next(30, 300);
				((AttemptDataModel)adm).AttemptDate = DateTime.Now;

				((AttemptDataModel)adm).TimesUsedSwing = rand.Next(0, 13);
				((AttemptDataModel)adm).TimesUsedBoom = rand.Next(0, 13);
				((AttemptDataModel)adm).TimesUsedTelescope = rand.Next(0, 13);
				((AttemptDataModel)adm).TimesUsedHoist = rand.Next(0, 13);

				((AttemptDataModel)adm).TimesUsedBrake = rand.Next(0, 13);
				((AttemptDataModel)adm).TimesUsedThrottle = rand.Next(0, 13);

				((AttemptDataModel)adm).TotalObjectives = rand.Next(0, 30);
				((AttemptDataModel)adm).ObjectivesCompleted = rand.Next(0, ((AttemptDataModel)adm).TotalObjectives);
				((AttemptDataModel)adm).TimesOverloadedCrane = rand.Next(0, 3);
				((AttemptDataModel)adm).TimesTwoBlockedCrane = rand.Next(0, 3);
				var y = ((AttemptDataModel)adm).Score = rand.Next(0, 100);
				((AttemptDataModel)adm).Passed = y >= x.MinPassingScore;
				((AttemptDataModel)adm).ExerciseCompleted = (((AttemptDataModel)adm).ObjectivesCompleted == ((AttemptDataModel)adm).TotalObjectives);
				((AttemptDataModel)adm).EndEdit();
				((AttemptDataModel)adm).State = ModelStates.ReadOnly;

				adata.Add(adm);
			}

			var bestScore = adata.Max(m => m.Score);
			var atmScore = from adm in adata where adm.Score == bestScore orderby adm.RunTime select adm;
			var bestTime = atmScore.Min(m => m.RunTime);
			int index = adata.FindIndex(m => m.Score == bestScore && m.RunTime == bestTime);
			x.AttemptsData = adata.ToArray();
			x.BestAttemptIndex = index;
			return ReportModel.ReadOnlyModel(x);
		}

		public void SetArchived(bool archive = true) {
			using(this.EditToken) this.Archived = archive;
		}
	}
	[KnownType(typeof(ExercisePenalties))]
	public partial class AttemptDataModel {
		[IgnoreDataMember]
		public ExercisePenalties Penalties {
			get { return (ExercisePenalties)this.PenaltyFlags; }
		}
		[IgnoreDataMember]
		public ReportModel ThisReport {
			get {
				if(ModelManager.ReportCollection.ContainsUID(this.ReportUID)) {
					return ModelManager.ReportCollection[this.ReportUID];
				} else {
					return null;
				}
			}
		}

		public static AttemptDataModel FromExerciseResults(ExerciseResults results, ExerciseModel exercise, int attemptNum) {
			var x = new AttemptDataModel() { IsSubModel = true };
			x.BeginEdit();

			x.RunTime = (int)results.RunTime;
			x.HookCollisions = results.HookCollisionsCount;
			x.LoadCollisions = results.LoadCollisionsCount;
			x.ExcessiveSwingingPenalty = results.SwingPenaltiesCount;
			x.LoadHeightPenalty = results.HeightPenaltiesCount;

			var score = ReportModelCollection.CalculateScore(results, exercise.ScoreSettings);
			x.Score = score;
			x.Passed = score >= exercise.ScoreSettings.MinimumPassingScore;

			x.AttemptDate = results.CompletionDate;

			x.AttemptNum = attemptNum;
			x.PenaltyFlags = (int)results.Penalties;
			x.ExerciseCompleted = results.ExerciseCompleted;
			x.CatastrophicFailure = results.CatastrophicFailure;
			x.PowerLineContactPenalties = results.PowerlineContactPenalties;
			x.PowerLineProximityPenalties = results.PowerlineProximityPenalties;
			x.ConeCollisions = results.ConeCollisionCount;
			x.WarningAcknowledgementFailures = results.WarningAcknowledgmentFailures;
			x.UnableToContinue = results.UnableToContinue;
			x.TimeLimitReached = results.TimeLimitReached;
			x.ExerciseCompleted = results.ExerciseCompleted;
			x.TimesUsedTelescope = results.TimesUsedTelescope;
			x.TimesUsedSwing = results.TimesUsedSwing;
			x.TimesUsedBoom = results.TimesUsedBoom;
			x.TimesUsedHoist = results.TimesUsedHoist;
			x.TimesUsedBrake = results.TimesUsedBrake;
			x.TimesUsedThrottle = results.TimesUsedThrottle;
			x.TotalObjectives = results.TotalObjectives;
			x.ObjectivesCompleted = results.ObjectivesCompleted;
			x.TimesOverloadedCrane = results.TimesOverloadedCrane;
			x.TimesTwoBlockedCrane = results.TimesTwoBlockedCrane;


			x.EndEdit();

			return x;
		}
	}

	[KnownType(typeof(ExerciseResults))]
	public partial class AssignmentModel {
		/// <summary>
		/// Gets the exercise.
		/// <para>Linked to ExerciseID</para>
		/// </summary>
		/// <value>
		/// The exercise.
		/// </value>
		[IgnoreDataMember, ChangedNotificationLink("ExerciseID"), ChangedNotificationLink("ExerciseUID")]
		public ExerciseModel Exercise {
			get {
				if(ModelManager.ExerciseCollection.ContainsUID(this.ExerciseUID)) {
					return ModelManager.ExerciseCollection[this.ExerciseUID];
				} else {
					return null;
				}
			}
		}
		/// <summary>
		/// Gets the user.
		/// <para>Linked to AssignedToID</para>
		/// </summary>
		/// <value>
		/// The user.
		/// </value>
		[IgnoreDataMember, ChangedNotificationLink("AssignedToID"), ChangedNotificationLink("AssignedToUID")]
		public UserModel User {
			get {
				if(ModelManager.UserCollection.ContainsUID(this.AssignedToUID)) {
					return ModelManager.UserCollection[this.AssignedToUID];
				} else {
					return null;
				}
			}
		}
		/// <summary>
		/// Gets the creator.
		/// <para>Linked to CreatorID</para>
		/// </summary>
		/// <value>
		/// The creator.
		/// </value>
		[IgnoreDataMember]
		public UserModel Creator {
			get {
				return ModelManager.UserCollection[CreatorUID];
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("LinkedReportID"), ChangedNotificationLink("LinkedReportUID")]
		public ReportModel LinkedReport {
			get {
				if(ModelManager.ReportCollection.ContainsUID(this.LinkedReportUID)) {
					return ModelManager.ReportCollection[this.LinkedReportUID];
				} else {
					return null;
				}
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("ScoringUID")]
		public ScoringDeductionsModel Scoring {
			get {
				return ModelManager.ScoringSetsCollection.GetByUID(ScoringUID);
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("LinkedReportID"), ChangedNotificationLink("LinkedReportUID")]
		public string BestScore {
			get {
				if(LinkedReport != null) {
					return LinkedReport.Score.ToString();
				}
				return "---";
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("GroupID"), ChangedNotificationLink("GroupUID")]
		public GroupModel Group {
			get {
				if(ModelManager.GroupCollection.ContainsUID(this.GroupUID)) {
					return ModelManager.GroupCollection[this.GroupUID];
				} else {
					return null;
				}
			}
		}
		[IgnoreDataMember]
		public bool IsExerciseLocked {
			get {
				if(Exercise != null) return Exercise.LockedForUpdate;
				return false;
			}
		}

		/// <summary>
		/// Updates the assignment.
		/// </summary>
		/// <param name="results">The results.</param>
		public void UpdateAssignment(ExerciseResults results) {
			if(!this.EditMode) {
				this.BeginEdit();

				if(this.AttemptsTaken < this.MaxAttempts) {
					this.AttemptsTaken++;

					if(this.AttemptsTaken >= this.MaxAttempts) {
						MarkComplete();
					}

					if(this.LinkedReportUID == Guid.Empty) {
						this.LinkedReportUID = ModelManager.ReportCollection.GenerateRunningReport2(this);
					}
					//if(this.LinkedReportID == -1) {
					//	this.LinkedReportID = ModelManager.ReportCollection.GenerateRunningReport(this);
					//}
					ModelManager.ReportCollection.UpdateRunningReport(this, results);
					this.BestAttempt = LinkedReport.BestAttemptIndex + 1;
					this.Passed = LinkedReport.Passed;

				}

				this.EndEdit();
			}
		}
		/// <summary>
		/// Marks this assignment as complete.
		/// </summary>
		public void MarkComplete() {
			using(this.EditToken) {
				this.Complete = true;
			}
			//if(!this.EditMode) {
			//	this.BeginEdit();
			//	this.Complete = true;
			//	this.EndEdit();
			//}

			if(this.LinkedReport != null) {
				using(this.LinkedReport.EditToken) {
					this.LinkedReport.CompletionDate = DateTime.Now;
				}
				//this.LinkedReport.BeginEdit();
				//this.LinkedReport.CompletionDate = DateTime.Now;
				//this.LinkedReport.EndEdit();
			}
		}
		public void MarkArchived() {
			using(this.EditToken) {
				this.Archived = true;
			}
		}
		public void OnRunAssignment() {
			if(Exercise != null) Exercise.SetLastUsed(DateTime.Now);
		}

		/// <summary>
		/// Called when [create].
		/// </summary>
		protected internal override void OnCreate() {
			base.OnCreate();
			//if(Exercise != null) {
			//	this.AssignmentName = Exercise.Name;
			//}
			this.LinkedReportID = -1;
			this.LinkedReportUID = Guid.Empty;
		}

		//protected override List<string> ValidateProperty(string propertyName) {
		//	var errors = new List<string>();
		//	switch(propertyName) {
		//		case nameof(this.MaxAttempts):
		//			if(this.MaxAttempts <= 0) {
		//				errors.Add("At least 1 attempt must be allowed.");
		//			}
		//			break;
		//		case nameof(this.ExerciseID):
		//			if(this.ExerciseID < 0) {
		//				errors.Add("No exercise selected");
		//			}
		//			break;
		//		case nameof(this.AssignmentName):
		//			if(string.IsNullOrWhiteSpace(this.AssignmentName)) {
		//				errors.Add("No assignment name specified.");
		//			}
		//			break;
		//		default:
		//			return base.ValidateProperty(propertyName);
		//	}

		//	return errors;
		//}
	}

	public partial class AssignmentModelCollection {
		protected internal override void UpdateUniqueReferencing() {
			base.UpdateUniqueReferencing();
			foreach(var m in Models) {
				if(m.AssignedToUID == Guid.Empty && ModelManager.UserCollection.ContainsID(m.AssignedToID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.AssignedToUID = ModelManager.UserCollection[m.AssignedToID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
				if(m.GroupUID == Guid.Empty && ModelManager.GroupCollection.ContainsID(m.GroupID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.GroupUID = ModelManager.GroupCollection[m.GroupID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
				if(m.GroupAssignmentUID == Guid.Empty && ModelManager.GroupAssignmentsCollection.ContainsID(m.GroupAssignmentID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.GroupAssignmentUID = ModelManager.GroupAssignmentsCollection[m.GroupAssignmentID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
				if(m.ExerciseUID == Guid.Empty && ModelManager.ExerciseCollection.ContainsID(m.ExerciseID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.ExerciseUID = ModelManager.ExerciseCollection[m.ExerciseID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
				if(m.LinkedReportUID == Guid.Empty && ModelManager.ReportCollection.ContainsID(m.LinkedReportID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.LinkedReportUID = ModelManager.ReportCollection[m.LinkedReportID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
			}
		}
	}

	public partial class GroupModel {
		[IgnoreDataMember]
		public UserModel Creator {
			get {
				return ModelManager.UserCollection[CreatorUID];
			}
		}
		[IgnoreDataMember]
		public override ModelGroupingOptions Grouping {
			get {
				return this.GroupIsTemplate ? ModelGroupingOptions.Template : base.Grouping;
			}
		}

		protected internal override void OnCreate() {
			base.OnCreate();
#pragma warning disable CS0618 // Type or member is obsolete
			if(string.IsNullOrWhiteSpace(Name)) Name = "New Group " + this.ID;
#pragma warning restore CS0618 // Type or member is obsolete
			//MemberIDs = new int[0];
		}

		protected override List<string> ValidateProperty(string propertyName) {
			var errors = new List<string>();
			if(propertyName == nameof(this.GroupIsTemplate)) {
				if(this.GroupIsTemplate && this.MemberUIDs.Length > 0) {
					errors.Add("Templates cannot have members,\n remove members to use this group as a template.");
				}
			}
			return errors;
		}

		/// <summary>
		/// Enumerates assignments and removes incomplete group assignments
		/// </summary>
		/// <param name="userUID">The user identifier.</param>
		public void PreRemoveMember(Guid userUID) {
			// TODO: fix this dumbness, don't change the filter like this. don't even bother with the filter. just us a predicate query
			var currentFilter = ModelManager.AssignmentCollection.CollectionView.Filter;
			// filter list of assignments for only this assignment
			ModelManager.AssignmentCollection.CollectionView.Filter = (a) => (a as AssignmentModel).AssignedToUID == userUID && (a as AssignmentModel).GroupUID == this.UID && (a as AssignmentModel).GroupAssignmentUID != Guid.Empty && !(a as AssignmentModel).Archived;

			var list = (from a in ModelManager.AssignmentCollection.CollectionView.Cast<AssignmentModel>() select a.UID).ToArray();
			foreach(var a in list) {
				ModelManager.AssignmentCollection.ActiveUID = a;
				ModelManager.AssignmentCollection.RemoveActiveSelection();
			}

			ModelManager.AssignmentCollection.CollectionView.Filter = currentFilter;
		}

		/// <summary>
		/// Enumerates group assignments and generates assignments for the user.
		/// </summary>
		/// <param name="userUID">The user identifier.</param>
		public void PreAddMember(Guid userUID) {
			var currentFilter = ModelManager.GroupAssignmentsCollection.CollectionView.Filter;
			// filter list of group assignments for only this group
			ModelManager.GroupAssignmentsCollection.CollectionView.Filter = (a) => (a as GroupAssignmentModel).GroupUID == this.UID;

			foreach(GroupAssignmentModel ga in ModelManager.GroupAssignmentsCollection.CollectionView) {
				ga.GenerateAndAssignAssignment(userUID);
			}

			ModelManager.GroupAssignmentsCollection.CollectionView.Filter = currentFilter;
		}

		/// <summary>
		/// Called when [delete].
		/// </summary>
		protected internal override void OnDelete() {
			// removed each member from the group before deleting the group to avoid orphaned assignments.
			foreach(var member in MemberUIDs) {
				PreRemoveMember(member);
			}
			base.OnDelete();
		}

		public void SetArchived(bool archive = true) {
			using(this.EditToken) this.Archived = archive;
		}
	}

	public partial class GroupModelCollection {
		protected internal override void UpdateUniqueReferencing() {
			base.UpdateUniqueReferencing();
			foreach(var m in Models) {
				if(m.MemberUIDs == null || (m.MemberUIDs.Length != m.MemberIDs.Length)) {
					using(m.EditToken) {
						m.MemberUIDs = new Guid[m.MemberIDs.Length];
						for(int i = 0; i < m.MemberIDs.Length; i++) {
							if(ModelManager.UserCollection.ContainsID(m.MemberIDs[i])) {
#pragma warning disable CS0618 // Type or member is obsolete
								m.MemberUIDs[i] = ModelManager.UserCollection[m.MemberIDs[i]].UID;
#pragma warning restore CS0618 // Type or member is obsolete
							}
						}
					}
				} else {
					for(int i = 0; i < m.MemberIDs.Length; i++) {
						if(m.MemberUIDs[i] == Guid.Empty && ModelManager.UserCollection.ContainsID(m.MemberIDs[i])) {
#pragma warning disable CS0618 // Type or member is obsolete
							using(m.EditToken) m.MemberUIDs[i] = ModelManager.UserCollection[m.MemberIDs[i]].UID;
#pragma warning restore CS0618 // Type or member is obsolete
						}
					}
				}
			}
		}

		public override void DuplicateCurrent() {
			if(!ActiveSelectionLocked && !ActiveSelectionNull) {
				var mb = ((GroupModel)ActiveSelection.Clone());
				var m = mb.Master;
				m.GroupIsTemplate = false;
				m.Name = $"{m.Name} Copy";
				var templateID = ActiveUID;
				AddNew(m);

				var p = ModelManager.GroupAssignmentsCollection.GetPrivateView();
				p.Filter = (a) => (a as GroupAssignmentModel).GroupUID == templateID;
				foreach(GroupAssignmentModel ga in p) {
					var ass = ((GroupAssignmentModel)ga.Clone());
					var assData = ass.Master;
					assData.GroupUID = ActiveUID;
					ModelManager.GroupAssignmentsCollection.AddNew(assData);
					ModelManager.GroupAssignmentsCollection.EndEditActiveSelection();
				}
			}
		}
	}

	public partial class GroupAssignmentModel {
		/// <summary>
		/// Gets the exercise.
		/// <para>Linked to ExerciseID</para>
		/// </summary>
		/// <value>
		/// The exercise.
		/// </value>
		[IgnoreDataMember, ChangedNotificationLink("ExerciseID"), ChangedNotificationLink("ExerciseUID")]
		public ExerciseModel Exercise {
			get {
				if(ModelManager.ExerciseCollection.ContainsUID(this.ExerciseUID)) {
					return ModelManager.ExerciseCollection[this.ExerciseUID];
				} else {
					return null;
				}
			}
		}
		/// <summary>
		/// Gets the creator.
		/// <para>Linked to CreatorID</para>
		/// </summary>
		/// <value>
		/// The creator.
		/// </value>
		[IgnoreDataMember]
		public UserModel Creator {
			get {
				return ModelManager.UserCollection[CreatorUID];
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("GroupID"), ChangedNotificationLink("GroupUID")]
		public GroupModel Group {
			get {
				if(ModelManager.GroupCollection.ContainsUID(this.GroupUID)) {
					return ModelManager.GroupCollection[this.GroupUID];
				} else {
					return null;
				}
			}
		}

		public AssignmentModel GenerateAndAssignAssignment(Guid userUID) {
			if(ModelManager.UserCollection[userUID]?.Archived ?? true) return null;
			var a = new Assignment() {
				AllowPractice = this.AllowPractice,
				MaxAttempts = this.MaxAttempts,
				CreationDate = DateTime.Now,
				AssignmentName = this.AssignmentName,
				ExerciseID = this.ExerciseID,
				ExerciseUID = this.ExerciseUID,
				AssignedToUID = userUID,
				GroupID = this.GroupID,
				GroupUID = this.GroupUID,
				GroupAssignmentID = /*this.ID*/ -1,
				GroupAssignmentUID = this.UID,
			};
			ModelManager.AssignmentCollection.AddNew(a);
			//ModelManager.AssignmentCollection.ActiveSelection.CreatorID = this.CreatorID; // temp
			ModelManager.AssignmentCollection.EndEditActiveSelection();
			return ModelManager.AssignmentCollection.ActiveSelection;
		}

		/// <summary>
		/// Adds this assignment to group members who don't have it
		/// </summary>
		public void ApplyToGroupMembers() {
			if(Group == null) return;
			// left excluding join ; selects all users who are members of this assignments group, but do not appear to already have this group assignment.
			//foreach(var id in (from a in Group.MemberIDs join b in (from x in ModelManager.AssignmentCollection.Models where x.GroupID == this.GroupID && x.GroupAssignmentID == this.ID select x) on a equals b.AssignedToID into j from b in j.DefaultIfEmpty() where b == null select a)) {
			//	GenerateAndAssignAssignment(id);
			//}

			foreach(var uid in (from a in Group.MemberUIDs join b in (from x in ModelManager.AssignmentCollection.Models where x.GroupUID == this.GroupUID && x.GroupAssignmentUID == this.UID select x) on a equals b.AssignedToUID into j from b in j.DefaultIfEmpty() where b == null select a)) {
				GenerateAndAssignAssignment(uid);
			}
		}

		/// <summary>
		/// Removes all assignments linked to this GA from members of this GA's owner group. removes reports if incomplete, leaves complete alone.
		/// </summary>
		public void RemoveFromGroupMembers() {
			if(Group == null) return;
			var currentFilter = ModelManager.AssignmentCollection.CollectionView.Filter;
			// filter list of assignments for only this assignment
			//ModelManager.AssignmentCollection.CollectionView.Filter = (a) => (a as AssignmentModel).GroupAssignmentID == this.ID && !(a as AssignmentModel).Archived && Group.MemberIDs.Contains((a as AssignmentModel).AssignedToID);
			ModelManager.AssignmentCollection.CollectionView.Filter = (a) => (a as AssignmentModel).GroupAssignmentUID == this.UID && !(a as AssignmentModel).Archived && Group.MemberUIDs.Contains((a as AssignmentModel).AssignedToUID);
			//var assignments = (from a in ModelManager.AssignmentCollection.CollectionView.Cast<AssignmentModel>() select a.ID).ToArray();
			var assignments = (from a in ModelManager.AssignmentCollection.CollectionView.Cast<AssignmentModel>() select a.UID).ToArray();
			foreach(var a in assignments) {
				ModelManager.AssignmentCollection.ActiveUID = a;
				if(ModelManager.AssignmentCollection.ActiveSelection.LinkedReport != null) {
					ModelManager.ReportCollection.ActiveUID = ModelManager.AssignmentCollection.ActiveSelection.LinkedReportUID;
					ModelManager.ReportCollection.RemoveActiveSelection();
				}
				ModelManager.AssignmentCollection.RemoveActiveSelection();
			}
			ModelManager.AssignmentCollection.CollectionView.Filter = currentFilter;
		}

		/// <summary>
		/// applies group assignment changes to member assignments
		/// </summary>
		public void BubbleAssignmentChanges() {
			var currentFilter = ModelManager.AssignmentCollection.CollectionView.Filter;
			//ModelManager.AssignmentCollection.CollectionView.Filter = (a) => (a as AssignmentModel).GroupAssignmentID == this.ID && !(a as AssignmentModel).Archived && !(a as AssignmentModel).Modified;
			ModelManager.AssignmentCollection.CollectionView.Filter = (a) => (a as AssignmentModel).GroupAssignmentUID == this.UID && !(a as AssignmentModel).Archived && !(a as AssignmentModel).Modified;
			foreach(var a in ModelManager.AssignmentCollection.CollectionView.Cast<AssignmentModel>()) {
				a.BeginEdit();
				a.MaxAttempts = this.MaxAttempts;
				a.AllowPractice = this.AllowPractice;
				a.AssignmentName = this.AssignmentName;
				a.EndEdit();
			}
			ModelManager.AssignmentCollection.CollectionView.Filter = currentFilter;
		}

		protected internal override void OnDelete() {
			RemoveFromGroupMembers();
			base.OnDelete();
		}
	}

	public partial class GroupAssignmentModelCollection {
		protected internal override void UpdateUniqueReferencing() {
			base.UpdateUniqueReferencing();
			foreach(var m in Models) {
				if(m.GroupUID == Guid.Empty && ModelManager.GroupCollection.ContainsID(m.GroupID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.GroupUID = ModelManager.GroupCollection[m.GroupID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
				if(m.ExerciseUID == Guid.Empty && ModelManager.ExerciseCollection.ContainsID(m.ExerciseID)) {
					using(m.EditToken) {
#pragma warning disable CS0618 // Type or member is obsolete
						m.ExerciseUID = ModelManager.ExerciseCollection[m.ExerciseID].UID;
#pragma warning restore CS0618 // Type or member is obsolete
					}
				}
			}
		}
	}

	public partial class ScoringDeductionsModelCollection {
		public override void AddNew() {
			//base.AddNew();
			base.AddNew(ScoringDeductions.Default);
		}

		protected internal override void ProcessOnLoadCollection() {
			foreach(var model in this.Models) {
				model.ProcessOnLoad();
			}
		}
	}

	[KnownType(typeof(ExercisePenalties))]
	public partial class ScoringDeductionsModel:ICommonInformation {
		private bool _IgnoreChanges = false;
		[IgnoreDataMember]
		public UserModel Creator {
			get {
				return ModelManager.UserCollection[CreatorUID];
			}
		}
		[IgnoreDataMember, ChangedNotificationLink("EnabledPenalties")]
		public ExercisePenalties EnabledPenaltyFlags {
			get { return (ExercisePenalties)EnabledPenalties; }
			set {
				if(EditMode) {
					if(this.EnabledPenalties != (int)value) {
						this.EnabledPenalties = (int)value;
						this.IsChanged = true;
						RaisePropertyChanged();
					}
				}
			}
		}
		[IgnoreDataMember]
		public override ModelGroupingOptions Grouping {
			get {
				return this.IsBuiltIn ? ModelGroupingOptions.BuiltIn : base.Grouping;
			}
		}

		protected internal override void OnCreate() {
			if(string.IsNullOrWhiteSpace(Name)) {
#pragma warning disable CS0618 // Type or member is obsolete
				Name = "New Scoring Set " + ID;
#pragma warning restore CS0618 // Type or member is obsolete
			} else {
				Name += " (Copy)";
			}
			if(string.IsNullOrWhiteSpace(Description)) {
				Description = string.Empty;
			}
			DateCreated = DateTime.Now;
			IsBuiltIn = false;
			base.OnCreate();
		}
		public override void EndEdit() {
			if(!_IgnoreChanges) {
				LastModified = DateTime.Now;
			}
			base.EndEdit();
		}
		public override void Generalize() {
			_IgnoreChanges = true;
			base.Generalize();
			using(EditToken) {
				DateCreated = new DateTime();
				LastModified = new DateTime();
				LastUsed = new DateTime();
				IsBuiltIn = true;
			}
			_IgnoreChanges = false;

		}
		public void SetArchived(bool archive = true) {
			using(this.EditToken) this.Archived = archive;
		}
		public void SetLastUsed(DateTime used) {
			using(this.EditToken) this.LastUsed = used;
		}
		internal void ProcessOnLoad() {
			if(string.IsNullOrWhiteSpace(Category)) {
				if(!string.IsNullOrWhiteSpace(this.Name)) {
					using(this.EditToken) {
						Category = this.Name.Split(' ').FirstOrDefault();
					}
				}
			}
		}

		public static implicit operator ScoringParameters(ScoringDeductionsModel a) {
			return new ScoringParameters() {
				MaxLoadHeight = a.LoadHeightThreshold,
				SwingAnglePenaltyLimit = a.SwingThreshold,
				HookCollisionSensitivity = a.HookCollisionSensitivity,
				LoadCollisionSensitivity = a.LoadCollisionSensitivity,
				LoadHeightTravelDistance = a.LoadHeightTravelDistance,
				LoadSetDownSensitivity = a.LoadSetDownSensitivity,
				ConeCollisionSensitivity = a.ConeCollisionSensitivity,
				HeightLimitIgnoredWithNoLoad = a.HeightLimitIgnoredwithNoLoad,
				SeparateConeCollisions = a.SeparateConeCollisions,
				SeperateCollisionPeneltyForCones = a.SeparateConeCollisions,
				ExerciseTimeLimit = a.ExerciseTimeLimit,
				PathDeviationDistance = a.PathDeviationDistance,
				//PowerlineProximityRadius = a.PowerlineProximityRadius,
				//WarningFailureTime = a.WarningTimeout,
				EnabledPenalties = a.EnabledPenaltyFlags
			};
		}
	}

	public partial struct ScoringDeductions {
		[IgnoreDataMember]
		public static ScoringDeductions Default {
			get {
				return new ScoringDeductions() {
					HookCollisionSensitivity = 1,
					LoadCollisionSensitivity = 1,
					LoadSetDownSensitivity = 1,
					ConeCollisionSensitivity = 1,
					LoadHeightTravelDistance = 4.5f,
					PathDeviationDistance = 0.3048f,
					PowerlineProximityRadius = 3.048f,

					SeparateConeCollisions = false,

					ExerciseTimeLimit = 0,
					WarningTimeout = 0,

					//PowerlineContactPenalty = 5,
					//PowerlineProximityPenalty = 5,
					//WarningAcknowledgementFailurePenalty = 5,
					ConeCollisionDeduction = 5,
					LoadCollisionDeduction = 5,
					HookCollisionDeduction = 5,
					ExcessiveSwingDeduction = 10,
					LoadHeightDeduction = 10,
					SwingThreshold = 10,
					LoadHeightThreshold = 1.524f,
					//EnabledPenalties = (int)(ExercisePenalties.ExcessiveSwinging | ExercisePenalties.LoadHeight | ExercisePenalties.TippedCrane | ExercisePenalties.CraneRanWhileOutOfLevel),
					EnabledPenalties = (int)(ExercisePenalties.ExcessiveSwinging | ExercisePenalties.LoadHeight),
					GeneralPenaltyDeduction = 5,
					PickupShockLoadingPenalty = 5,
					SetdownShockLoadingPenalty = 5,
					MinimumPassingScore = 75,
					IncompleteExerciseMaxScore = 50,
					HeightLimitIgnoredwithNoLoad = true,
					PathDeviationPenalty = 0
				};
			}
		}
	}

	public partial class SimulatorSettingsModel {
		[IgnoreDataMember]
		public SimTypes SimTypeValue {
			get { return (SimTypes)this.SimulatorType; }
		}
	}
}